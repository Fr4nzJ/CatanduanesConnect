import os
import uuid
import json
import logging
from logging.handlers import RotatingFileHandler
import random
from datetime import datetime, timedelta
from functools import wraps
from typing import Optional, Dict, Any, List
import re

from flask import Flask, render_template, request, redirect, url_for, flash, jsonify, g
from werkzeug.exceptions import HTTPException
from flask_login import LoginManager, login_user, login_required, logout_user, current_user
from flask_bcrypt import Bcrypt
from flask_mail import Mail, Message
from flask_bootstrap import Bootstrap
from werkzeug.utils import secure_filename
from dotenv import load_dotenv
from neo4j import GraphDatabase, exceptions as neo4j_exceptions
import openai

from models import (
    User, Business, Job, Application, 
    Review, Service, Notification, Activity
)
from decorators import admin_required
from admin_routes import admin

# Initialize Flask app
app = Flask(__name__)

# Register blueprints
app.register_blueprint(admin)

# Set up enhanced logging
if not os.path.exists('logs'):
    os.mkdir('logs')

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        RotatingFileHandler(
            'logs/app.log', 
            maxBytes=10240,
            backupCount=10
        )
    ])

logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Configure Flask app and extensions
app.config.update(
    SECRET_KEY=os.getenv('FLASK_SECRET_KEY'),
    SESSION_COOKIE_SECURE=True,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SAMESITE='Lax',
    PORT=int(os.getenv('PORT', 5000)),
    HOST='0.0.0.0'
)

# Initialize OpenAI configuration
openai.api_key = os.getenv('OPENAI_API_KEY')

# Initialize Neo4j connection
NEO4J_URI = os.getenv("NEO4J_URI")
NEO4J_USERNAME = os.getenv("NEO4J_USERNAME")
NEO4J_PASSWORD = os.getenv("NEO4J_PASSWORD")
DATABASE = os.getenv("NEO4J_DATABASE", "neo4j")

if not all([NEO4J_URI, NEO4J_USERNAME, NEO4J_PASSWORD]):
    logger.error("Missing required Neo4j environment variables!")
    raise ValueError("Missing required Neo4j environment variables!")

# Neo4j driver setup
try:
    driver = GraphDatabase.driver(
        NEO4J_URI,
        auth=(NEO4J_USERNAME, NEO4J_PASSWORD)
    )
    with driver.session(database=DATABASE) as session:
        result = session.run("RETURN 1")
        result.single()
    logger.info("Successfully connected to Neo4j database")
except Exception as e:
    logger.error(f"Failed to connect to Neo4j: {str(e)}")
    raise

def is_safe_query(query: str) -> bool:
    """Check if a Cypher query is safe to execute."""
    dangerous_keywords = [
        r"\bDELETE\b",
        r"\bCREATE\b",
        r"\bMERGE\b",
        r"\bSET\b",
        r"\bREMOVE\b",
        r"\bDROP\b"
    ]
    
    query = query.upper()
    return all(not re.search(keyword, query) for keyword in dangerous_keywords)

def generate_cypher_query(message: str) -> Optional[str]:
    """Use GPT to generate a Cypher query from a natural language message."""
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4-mini",
            messages=[
                {"role": "system", "content": "You are a Cypher query generator. Generate only MATCH...RETURN queries. Never use CREATE, DELETE, MERGE, SET, REMOVE, or DROP. If the user's request requires modification, respond with None."},
                {"role": "user", "content": f"Generate a Cypher query for: {message}"}
            ],
            temperature=0
        )
        
        query = response.choices[0].message['content'].strip()
        return query if is_safe_query(query) else None

    except Exception as e:
        logger.error(f"Error generating Cypher query: {str(e)}")
        return None

def format_db_results(results: List[Dict[str, Any]], original_question: str) -> str:
    """Use GPT to format database results into a natural response."""
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4-mini",
            messages=[
                {"role": "system", "content": "You are a helpful assistant that converts database results into natural language responses."},
                {"role": "user", "content": f"Question: {original_question}\nDatabase results: {results}\nPlease format this into a natural response."}
            ],
            temperature=0.7
        )
        
        return response.choices[0].message['content']

    except Exception as e:
        logger.error(f"Error formatting results: {str(e)}")
        return "I found some information but had trouble formatting it. Please try asking in a different way."

def get_chatbot_response(message: str) -> str:
    """Get a general chatbot response without database query."""
    try:
        response = openai.ChatCompletion.create(
            model="gpt-4-mini",
            messages=[
                {"role": "system", "content": "You are a helpful assistant for Catanduanes Connect, a platform that connects businesses, job seekers, and service providers in Catanduanes. Be friendly and professional."},
                {"role": "user", "content": message}
            ],
            temperature=0.7
        )
        
        return response.choices[0].message['content']

    except Exception as e:
        logger.error(f"Error getting chatbot response: {str(e)}")
        return "I'm having trouble right now. Please try again later."

@app.route('/chat')
def chat():
    """Render the chat interface."""
    return render_template('chat.html')

@app.route('/chat', methods=['POST'])
def process_message():
    """Process chat messages and return responses."""
    try:
        data = request.get_json()
        if not data or 'message' not in data:
            return jsonify({'error': 'No message provided'}), 400

        message = data['message'].strip()

        # First, try to generate a Cypher query
        cypher_query = generate_cypher_query(message)

        if cypher_query:
            # Query involves database data
            try:
                with driver.session(database=DATABASE) as session:
                    results = session.run(cypher_query).data()
                    
                    if results:
                        # Format the results using GPT
                        response = format_db_results(results, message)
                    else:
                        response = "I couldn't find any data matching your request. Could you please try asking in a different way?"

            except Exception as e:
                logger.error(f"Database query error: {str(e)}")
                response = "I encountered an error while searching the database. Please try again."

        else:
            # General conversation
            response = get_chatbot_response(message)

        return jsonify({
            'response': response,
            'timestamp': datetime.now().isoformat()
        })

    except Exception as e:
        logger.error(f"Chat processing error: {str(e)}")
        return jsonify({
            'error': 'Something went wrong. Please try again later.'
        }), 500

# Rest of your existing app.py code below...